#!/usr/bin/perl

use warnings;
use strict;
use utf8;

use POSIX qw(strftime locale_h);
use File::Basename;
use IO::Socket;
use threads;
use LWP::MediaTypes qw(guess_media_type);

sub sigpipe_handler {
  print "yes";
}

$SIG{PIPE} = "IGNORE";

# 默认端口号
my $DEFAULT_PORT = 1111;
my $CRLF = "\015\012";

# 服务器端口号
my $server_port;

# 处理命令行参数
if (@ARGV == 1 && $ARGV[0] =~ /^\d+$/) {
  $server_port = $ARGV[0];
} elsif (@ARGV == 0) {
  $server_port = $DEFAULT_PORT;
} else {
  print STDERR "phs <端口号>";
  exit(1);  
}

# 创建TCP Socket服务器实例
my $server = IO::Socket::INET->new(
			     LocalPort => $server_port,
			     ReuseAddr => 1,
			     Listen => 10  # Listen是什么意思
			    );

while (my $client = $server->accept) {

  # 启动线程处理TCP请求
  async(sub {
	  
	  # Socket句柄
	  my $client = shift;
	   
	  # Protocol和HTTP Header
	  my($protocol, $headers);
	  $protocol = <$client>;
	  while (<$client>) {
	    last if /^\s*$/;

	    # 读取 Header
	    my($k, $v) = ($_ =~ /(.*?): (.*)/);
	    $headers->{$k} = $v;
	    }

	  # 获取Path
	  my ($req_path) = $protocol =~ /\S* (\S*) /;
	  (my $quest_string = $req_path) =~ s#.*\?##;
	  $req_path =~ s#\?.*$##;
	  my $filename = ".$req_path";

	  # 处理escaped characters
	  $filename =~ s#%([0-9a-zA-Z]{2})#pack "c", hex($1)#ge;

	  # 处理POST请求
	  if ($protocol =~ /^POST/) {
	    unless (-d $filename) {
	      # 500;
	      return;
	    }

	    # content长度
	    my $content_len = $headers->{"Content-Length"};

	    return unless $content_len;
	    my $bytes_read = 0;
	    my $boundary = <$client>;
	    use bytes;
	    my $boundary_length = length $boundary;
	    $bytes_read += $boundary_length;
	    $boundary =~ s#\r\n$##;
	    while (<$client>) {
	      $bytes_read += length;
	      last if /^\s*$/;
	      my($k, $v) = ($_ =~ /(.*?): (.*)/);
	      $headers->{$k} = $v;
	    }
	    my($upload_filename) = ($headers->{"Content-Disposition"} =~ /filename="(.*)"/);	    
	    open my $fh, ">", "$filename/$upload_filename";
	    while (<$client>) {
	      my $line_len = length;
	      $bytes_read += $line_len;
	      if ($bytes_read >= $content_len - 4 - $boundary_length) {
		$_ =~ s#\r\n$##;
		print $fh $_;
		last;
	      }		
	      print $fh $_;
	    }
	    no bytes;
	    close $fh;

	    my $response = "HTTP/1.1 200 OK$CRLF";
	    $response .= "Content-Type: " . "text/plain" . "$CRLF";
	    $response .= "Content-Length: " . 2 . "$CRLF";
	    my $old_locale = setlocale(LC_TIME, "en_US.utf-8");
	    $response .= "Date: " . (strftime "%a, %d %b %Y %T", gmtime) . " GMT$CRLF";
	    setlocale(LC_TIME, $old_locale);
	    $response .= "Last-Modified: Tue, 02 Jun 2009 11:03:57 GMT$CRLF";
	    $response .= "Server: lulu_simple_http_server/1.0.0$CRLF";
	    $response .= "$CRLF";
	    $response .= "OK";
	    print $client $response;
	    close $client;
	  } elsif ($protocol =~ /^GET/) {
	    if (-f $filename) {
	      my($file_size) = (stat $filename)[7];
	      my $response = "HTTP/1.1 200 OK$CRLF";
	      $response .= "Content-Type: " . guess_media_type($filename) . "$CRLF";
	      $response .= "Content-Length: " . $file_size . "$CRLF";
	      my $old_locale = setlocale(LC_TIME, "en_US.utf-8");
	      $response .= "Date: " . (strftime "%a, %d %b %Y %T", gmtime) . " GMT$CRLF";
	      setlocale(LC_TIME, $old_locale);
	      $response .= "Last-Modified: Tue, 02 Jun 2009 11:03:57 GMT$CRLF";
	      $response .= "Server: lulu_simple_http_server/1.0.0$CRLF";
	      $response .= "$CRLF";
	      print $client $response;
	      open my($fh), $filename;
	      binmode $fh;
	      my $buf = "";
	      my $n;
	      while ($n = sysread($fh, $buf, 8*1024)) {
		last unless $n;
		die "sasa" unless syswrite $client, $buf;
	      }
	      close $fh;
	      
	    } elsif (-d $filename) {
	      
	      if ($quest_string =~ /zipdownload=1/) {
		my($basename, $dirname);
		$basename = basename $filename;
		$dirname = dirname $filename;
		my $response = "HTTP/1.1 200 OK$CRLF";
		$response .= "Content-Type: " . "application/zip" . "$CRLF";
		$response .= "Content-Disposition: attachment;file=\"${basename}.zip\"";
		my $old_locale = setlocale(LC_TIME, "en_US.utf-8");
		$response .= "Date: " . (strftime "%a, %d %b %Y %T", gmtime) . " GMT$CRLF";
		setlocale(LC_TIME, $old_locale);
		$response .= "Last-Modified: Tue, 02 Jun 2009 11:03:57 GMT$CRLF";
		$response .= "Server: lulu_simple_http_server/1.0.0$CRLF";
		$response .= "$CRLF";
		print $client $response;
		my $pwd = $ENV{PWD};
		chdir $dirname;
		open my($fh), "zip -q -0 -r - $basename |";
		binmode $fh;
		my $buf = "";
		my $n;
		while ($n = sysread($fh, $buf, 8*1024)) {
		  last unless $n;
		  die "sasa" unless syswrite $client, $buf;
		}
		close $fh;
		chdir $pwd;
	      } else {	    
		my $html = "";
		$html .= "<html>";
		$html .= "<head>";
		$html .= "<title></title>";
		$html .= '<meta http-equiv="Content-Type" content="text/html; charset=utf-8">';
		$html .= "</head>";
		$html .= "<body>";
		$html .= "<table>";
		$html .= "<tr>";
		$html .= "<td>";
		$html .= "<form method='post' enctype='multipart/form-data'>";
		$html .= "<input type='file' name='upload'/>";
		$html .= "<input type='submit'/>";
		$html .= "</form>";
		$html .= "</td>";
		$html .= "</tr>";
		opendir my ($dirh), $filename;
		$filename =~ s#/$##;
		for (readdir $dirh) {
		  $html .= "<tr>";
		  $html .= "<td>";
		  if (-d "$filename/$_") {
		    $html .= qq(<a href="/$filename/$_">$_</a>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="/$filename/$_?zipdownload=1">Download ZIP file</a>);		  
		  } else {
		    $html .= qq(<a href="/$filename/$_">$_</a>);
		  }
		  $html .= "</td>";
		  $html .= "</tr>";
		}
		$html .= "</table>";
		$html .= "</body>";		
		$html .= "</html>";
		my $response = "HTTP/1.1 200 OK$CRLF";
		$response .= "Content-Type: text/html$CRLF";
		$response .= "Content-Length: " . (length $html) . "$CRLF";
		my $old_locale = setlocale(LC_TIME, "en_US.utf-8");
		$response .= "Date: " . (strftime "%a, %d %b %Y %T", gmtime) . " GMT$CRLF";
		setlocale(LC_TIME, $old_locale);
		$response .= "Connection: close$CRLF";
		$response .= "Server: lulu_simple_http_server/1.0.0$CRLF";
		$response .= "$CRLF";
		$response .= $html;
		print $client $response;	      
		
	      }	      
	    } else {
	      #404
	    }
	  }
	  close $client;
	}, $client)->detach;
}
